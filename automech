#!/usr/bin/env python
""" compute geometries for species and store them in xyz files
"""
import os
import sys
from argparse import ArgumentParser
from argparse import ArgumentDefaultsHelpFormatter as Formatter
import logging
import from_qtc.obtools
import automechanic.io

# required arguments
MECH_TXT_REQ_INP_AINF = (
    (),
    (('dest', '<mechanism_txt>'),
     ('type', str),
     ('help', "[i] CHEMKIN mechanism file"))
)
SPC_CSV_REQ_INP_AINF = (
    (),
    (('dest', '<species_csv>'),
     ('type', str),
     ('help', "[i] CSV with species information"))
)
RXN_JSON_REQ_INP_AINF = (
    (),
    (('dest', '<reactions_json>'),
     ('type', str),
     ('help', "[i] RMG's reaction queue JSON file"))
)
SPC_JSON_REQ_INP_AINF = (
    (),
    (('dest', '<species_json>'),
     ('type', str),
     ('help', "[i] RMG's species queue JSON file"))
)

# optional arguments
SPC_CSV_OPT_OUT_AINF = (
    ('-S', '--species_csv_out'),
    (('type', str),
     ('default', 'species.csv'),
     ('help', "[o] CSV with species information"))
)
RXN_CSV_OPT_OUT_AINF = (
    ('-R', '--reactions_csv_out'),
    (('type', str),
     ('default', 'reactions.csv'),
     ('help', "[o] CSV with reactions information"))
)
GEOM_DIR_AINF = (
    ('-D', '--geom_dir'),
    (('type', str),
     ('default', 'geoms'),
     ('help', "[o] directory for storing geometry xyz files"))
)

# generic action options
PREFIX_AINF = (
    ('-P', '--prefix'),
    (('type', str),
     ('default', '.'),
     ('help', "[o] prefix for all output"))
)
LOG_FILE_NAME_AINF = (
    ('-L', '--log_file_name'),
    (('type', str),
     ('help', "[o] name of the log file for automech output"))
)
LOG_LEVEL_AINF = (
    ('-v', '--log_level'),
    (('type', int),
     ('default', 20),
     ('help', "log verbosity: 20=INFO, 10=DEBUG"))
)
PRINT_OUT_AINF = (
    ('-p', '--print_out'),
    (('action', 'store_true'),
     ('help', "print log output to screen"))
)


def _parser(prog, ainf_lst=()):
    parser = ArgumentParser(prog=prog, formatter_class=Formatter,
                            add_help=False)

    for args, kwargs in ainf_lst:
        args = tuple(args)
        kwargs = dict(kwargs)
        parser.add_argument(*args, **kwargs)

    return parser


def _get_help(parser, argv):
    if len(argv) == 1 and ('-h' in argv or '--help' in argv):
        parser.print_help()
        parser.exit()


def _argument_dictionary(argv, prog, ainf_lst=()):
    parser = _parser(prog, ainf_lst)
    _get_help(parser, argv)
    arg_dct = vars(parser.parse_args(argv))
    return arg_dct


def _freeze_dictionary(items):
    return tuple(dict(items).items())


def _unfreeze_dictionary(items):
    return dict(items)


def _freeze_arginfo(ainf):
    args, kwargs = ainf
    frozen_kwargs = _freeze_dictionary(kwargs)
    return (args, frozen_kwargs)


def _unfreeze_arginfo(ainf):
    args, kwargs = ainf
    unfrozen_kwargs = _unfreeze_dictionary(kwargs)
    return (args, unfrozen_kwargs)


def _arginfo_add_help(ainf, help_str):
    args, kwargs = _unfreeze_arginfo(ainf)
    kwargs['help'] += '; {:s}'.format(help_str)
    return _freeze_arginfo((args, kwargs))


def _arginfo_set_default(ainf, default_val):
    args, kwargs = _unfreeze_arginfo(ainf)
    kwargs['default'] = default_val
    return _freeze_arginfo((args, kwargs))


def _arginfo_key(ainf):
    key = None

    args, kwargs = _unfreeze_arginfo(ainf)
    if args and args[-1].startswith('--'):
        key = args[-1][2:]
    elif 'dest' in kwargs:
        key = kwargs['dest']
    else:
        raise ValueError("Invalid argument information.")

    return key


def _arginfo_value(arg_dct, ainf):
    key = _arginfo_key(ainf)
    return arg_dct[key]


def main(argv):
    """ main function
    """
    _route_subcommand(
        argv=argv,
        cmd='automech',
        subcmd_dct={
            'init': init,
            'init_from_rmg': init_from_rmg,
            'divide': divide,
            'chemkin': chemkin_main,
            'get': get_main,
            'csv': csv_main,
            'additions': additions_main,
            'abstractions': abstractions_main,
            'migrations': migrations_main
        }
    )


def init(argv):
    """ initialize a mechanism
    """
    spc_csv_ainf = _arginfo_add_help(
        SPC_CSV_REQ_INP_AINF,
        help_str="columns: 'species', 'species_id'")
    therm_txt_arginfo = (('-t', '--therm_txt'), {
        'type': str,
        'default': None,
        'help': "[i] CHEMKIN thermo data file"
    })
    no_thermo_arginfo = (('-w', '--without_thermo'), {
        'action': 'store_true',
        'help': "Initialize without thermo data"
    })
    parser = _init_parser(MECH_TXT_REQ_INP_AINF, spc_csv_ainf,
                          therm_txt_arginfo, no_thermo_arginfo)
    _get_help(parser, argv)

    args = vars(parser.parse_args(argv))

    mech_txt = args['<mechanism_txt>']
    spc_csv = args['<species_csv>']
    therm_txt = args['therm_txt']
    abs_mech_txt = os.path.abspath(mech_txt)
    abs_spc_csv = os.path.abspath(spc_csv)
    abs_therm_txt = os.path.abspath(therm_txt) if therm_txt else None

    with _ChangeDirectory(args['prefix']):
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.init(
            mech_txt=abs_mech_txt,
            spc_csv=abs_spc_csv,
            rxn_csv_out=args['reactions_csv_out'],
            spc_csv_out=args['species_csv_out'],
            geom_dir=args['geom_dir'],
            id2path=from_qtc.obtools.get_smiles_filename,
            therm_txt=abs_therm_txt,
            without_thermo=args['without_thermo'],
            logger=logger
        )


def init_from_rmg(argv):
    """ initialize a mechanism from an RMG json file
    """
    prog = 'automech init_from_rmg'
    ainf_lst = (
        RXN_JSON_REQ_INP_AINF,
        SPC_JSON_REQ_INP_AINF,
        _arginfo_add_help(RXN_CSV_OPT_OUT_AINF,
                          help_str="columns: 'reaction_id'"),
        _arginfo_add_help(SPC_CSV_OPT_OUT_AINF,
                          help_str="columns: 'species_id', 'path'"),
        GEOM_DIR_AINF,
        PREFIX_AINF,
        _arginfo_set_default(LOG_FILE_NAME_AINF,
                             default_val='init.log'),
        LOG_LEVEL_AINF,
        PRINT_OUT_AINF
    )
    arg_dct = _argument_dictionary(argv, prog, ainf_lst)

    rxn_json_val = os.path.abspath(
        _arginfo_value(arg_dct, RXN_JSON_REQ_INP_AINF))
    spc_json_val = os.path.abspath(
        _arginfo_value(arg_dct, SPC_JSON_REQ_INP_AINF))
    rxn_csv_out_val = (
        _arginfo_value(arg_dct, RXN_CSV_OPT_OUT_AINF))
    spc_csv_out_val = (
        _arginfo_value(arg_dct, SPC_CSV_OPT_OUT_AINF))
    geom_dir_val = (
        _arginfo_value(arg_dct, GEOM_DIR_AINF))
    prefix_val = (
        _arginfo_value(arg_dct, PREFIX_AINF))
    log_file_name_val = (
        _arginfo_value(arg_dct, LOG_FILE_NAME_AINF))
    log_level_val = (
        _arginfo_value(arg_dct, LOG_LEVEL_AINF))
    print_out_val = (
        _arginfo_value(arg_dct, PRINT_OUT_AINF))

    with _ChangeDirectory(prefix_val):
        logger = _logger(
            log_file_name=log_file_name_val,
            log_level=log_level_val,
            print_out=print_out_val
        )
        automechanic.io.init_from_rmg(
            mech_json=rxn_json_val,
            spc_json=spc_json_val,
            rxn_csv_out=rxn_csv_out_val,
            spc_csv_out=spc_csv_out_val,
            geom_dir=geom_dir_val,
            id2path=from_qtc.obtools.get_smiles_filename,
            logger=logger
        )


def chemkin_main(argv):
    """ main function for operating on chemkin files
    """
    _route_subcommand(
        argv=argv,
        cmd='automech chemkin',
        subcmd_dct={
            'to_csv': chemkin_to_csv
        }
    )


def chemkin_to_csv(argv):
    """ get chemkin reactions
    """
    raise NotImplementedError(argv)


def get_main(argv):
    """ main function for getters
    """
    _route_subcommand(
        argv=argv,
        cmd='automech get',
        subcmd_dct={
            'arrhenius': get_arrhenius
        }
    )


def get_arrhenius(argv):
    """ get arrhenius paramaters
    """
    parser = _action_parser(prog='automech get arrhenius',
                            log_file_name='arrhenius.log',
                            prefix=True)
    parser.add_argument(dest='<reactions_csv>',
                        type=str,
                        default='reactions.csv',
                        help="[i(o)] csv with 'reaction_id' column")
    _get_help(parser, argv)

    args = vars(parser.parse_args(argv))

    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.get_arrhenius(
            rxn_csv=os.path.join(
                locator.working_directory, args['<reactions_csv>']),
            logger=logger
        )


def csv_main(argv):
    """ main function for csv operations
    """
    _route_subcommand(
        argv=argv,
        cmd='automech csv',
        subcmd_dct={
            'reindex': csv_reindex,
            'sort': csv_sort,
            'merge': csv_merge,
            'intersect': csv_intersect
        }
    )


def csv_reindex(argv):
    """ (over)write the 'index' column in a csv file
    """
    parser = _action_parser(prog='automech csv reindex',
                            log_file_name='reindex.log',
                            prefix=True)
    parser.add_argument(dest='<table_csv>',
                        type=str,
                        help="[i(o)] csv file")
    _get_help(parser, argv)

    args = vars(parser.parse_args(argv))

    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.csv_reindex(
            table_csv=os.path.join(
                locator.working_directory, args['<table_csv>']),
            logger=logger
        )


def csv_sort(argv):
    """ sort a csv file by column
    """
    parser = _action_parser(prog='automech csv sort',
                            log_file_name='sort.log',
                            prefix=True)
    parser.add_argument(dest='<table_csv>',
                        type=str,
                        help="[i(o)] csv file")
    parser.add_argument(dest='<col_key>',
                        type=str,
                        help="the name of the colum to sort by")
    parser.add_argument('-d', '--descending',
                        action='store_true',
                        help="sort in descending order")
    _get_help(parser, argv)

    args = vars(parser.parse_args(argv))

    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.csv_sort(
            table_csv=os.path.join(
                locator.working_directory, args['<table_csv>']),
            col_key=args['<col_key>'],
            descending=args['descending'],
            logger=logger
        )


def csv_merge(argv):
    """ merge reaction csv files
    """
    parser = _action_parser(prog='automech csv merge',
                            log_file_name='merge.log',
                            prefix=True)
    parser.add_argument(dest='<table_csvs>',
                        type=str,
                        nargs='+',
                        help="[i] csv files")
    parser.add_argument(dest='<col_key>',
                        type=str,
                        help="the name of the colum to sort by")
    parser.add_argument('-T', '--table_csv_out',
                        type=str,
                        default='table.csv',
                        help="[o] csv file")
    _get_help(parser, argv)

    args = vars(parser.parse_args(argv))

    table_csvs = args['<table_csvs>']
    assert len(table_csvs) > 1
    table_csvs = tuple(map(os.path.abspath, table_csvs))

    with _ChangeDirectory(args['prefix']):
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.csv_merge(
            table_csvs=table_csvs,
            col_key=args['<col_key>'],
            table_csv_out=args['table_csv_out'],
            logger=logger
        )


def csv_intersect(argv):
    """ intersect reaction csv files
    """
    parser = _action_parser(prog='automech csv intersect',
                            log_file_name='intersect.log',
                            prefix=True)
    parser.add_argument(dest='<table_csvs>',
                        type=str,
                        nargs='+',
                        help="[i] csv files")
    parser.add_argument(dest='<col_key>',
                        type=str,
                        help="the name of the colum to sort by")
    parser.add_argument('-T', '--table_csv_out',
                        type=str,
                        default='table.csv',
                        help="[o] csv file")
    _get_help(parser, argv)

    args = vars(parser.parse_args(argv))

    table_csvs = args['<table_csvs>']
    assert len(table_csvs) > 1
    table_csvs = tuple(map(os.path.abspath, table_csvs))

    with _ChangeDirectory(args['prefix']):
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.csv_intersect(
            table_csvs=table_csvs,
            col_key=args['<col_key>'],
            table_csv_out=args['table_csv_out'],
            logger=logger
        )


def additions_main(argv):
    """ main function for additions
    """
    _route_subcommand(
        argv=argv,
        cmd='automech additions',
        subcmd_dct={
            'init': additions_init,
            'run': additions_run,
            'run_batch': additions_run_batch
        }
    )


def abstractions_main(argv):
    """ main function for abstractions
    """
    _route_subcommand(
        argv=argv,
        cmd='automech abstractions',
        subcmd_dct={
            'init': abstractions_init,
            'run_batch': abstractions_run_batch
        }
    )


def migrations_main(argv):
    """ main function for migrations
    """
    _route_subcommand(
        argv=argv,
        cmd='automech migrations',
        subcmd_dct={
            'init': migrations_init,
            'run_batch': migrations_run_batch
        }
    )


def abstractions_init(argv):
    """ initialization for abstractions
    """
    parser = _reactions_init_parser('abstractions')
    _get_help(parser, argv)
    args = vars(parser.parse_args(argv))
    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )

        automechanic.io.abstractions_init(
            spc_csv=os.path.join(
                locator.working_directory, args['<species_csv>']),
            rxn_csv=os.path.join(
                locator.working_directory, args['<reactions_csv>']),
            rxn_csv_out=args['reactions_csv_out'],
            cdt_csv_out=args['candidates_csv_out'],
            logger=logger
        )


def additions_init(argv):
    """ initialization for additions
    """
    parser = _reactions_init_parser('additions')
    _get_help(parser, argv)
    args = vars(parser.parse_args(argv))
    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )

        automechanic.io.additions_init(
            spc_csv=os.path.join(
                locator.working_directory, args['<species_csv>']),
            rxn_csv=os.path.join(
                locator.working_directory, args['<reactions_csv>']),
            rxn_csv_out=args['reactions_csv_out'],
            cdt_csv_out=args['candidates_csv_out'],
            logger=logger
        )


def migrations_init(argv):
    """ initialization for migrations
    """
    parser = _reactions_init_parser('migrations')
    _get_help(parser, argv)
    args = vars(parser.parse_args(argv))
    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )

        automechanic.io.migrations_init(
            spc_csv=os.path.join(
                locator.working_directory, args['<species_csv>']),
            rxn_csv=os.path.join(
                locator.working_directory, args['<reactions_csv>']),
            rxn_csv_out=args['reactions_csv_out'],
            cdt_csv_out=args['candidates_csv_out'],
            logger=logger
        )


def additions_run(argv):
    """ runner for additions
    """
    parser = _reactions_run_parser('additions')
    _get_help(parser, argv)
    automech_argv, job_argv = _split_command_args(argv)
    args = vars(parser.parse_args(automech_argv))
    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )

        automechanic.io.additions_run(
            spc_csv=os.path.join(
                locator.working_directory, args['<species_csv>']),
            rxn_csv=os.path.join(
                locator.working_directory, args['<reactions_csv>']),
            tpl_txt=os.path.join(
                locator.working_directory, args['<template_txt>']),
            job_argv=job_argv,
            run_dir=args['run_dir'],
            rxn_idxs=args['indices'],
            nodes=args['nodes'],
            logger=logger
        )


def abstractions_run_batch(argv):
    """ runner for abstractions
    """
    parser = _reactions_run_batch_parser('abstractions')
    _get_help(parser, argv)
    automech_argv, job_argv = _split_command_args(argv)
    args = vars(parser.parse_args(automech_argv))
    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.abstractions_run_batch(
            spc_csv=os.path.join(
                locator.working_directory, args['species_csv']),
            batch_csv=os.path.join(
                locator.working_directory, args['batch_csv']),
            rxn_csv=os.path.join(
                locator.working_directory, args['reactions_csv']),
            tmp_txt=os.path.join(
                locator.working_directory, args['template_txt']),
            tmp_keyval_str=args['template_keyvals'],
            run_dir=args['run_dir'],
            id2path=from_qtc.obtools.get_smiles_filename,
            job_argv=job_argv,
            logger=logger
        )


def additions_run_batch(argv):
    """ runner for additions
    """
    parser = _reactions_run_batch_parser('additions')
    _get_help(parser, argv)
    automech_argv, job_argv = _split_command_args(argv)
    args = vars(parser.parse_args(automech_argv))
    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.additions_run_batch(
            spc_csv=os.path.join(
                locator.working_directory, args['species_csv']),
            batch_csv=os.path.join(
                locator.working_directory, args['batch_csv']),
            rxn_csv=os.path.join(
                locator.working_directory, args['reactions_csv']),
            tmp_txt=os.path.join(
                locator.working_directory, args['template_txt']),
            tmp_keyval_str=args['template_keyvals'],
            run_dir=args['run_dir'],
            id2path=from_qtc.obtools.get_smiles_filename,
            job_argv=job_argv,
            logger=logger
        )


def migrations_run_batch(argv):
    """ runner for migrations
    """
    parser = _reactions_run_batch_parser('migrations')
    _get_help(parser, argv)
    automech_argv, job_argv = _split_command_args(argv)
    args = vars(parser.parse_args(automech_argv))
    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )
        automechanic.io.migrations_run_batch(
            spc_csv=os.path.join(
                locator.working_directory, args['species_csv']),
            batch_csv=os.path.join(
                locator.working_directory, args['batch_csv']),
            rxn_csv=os.path.join(
                locator.working_directory, args['reactions_csv']),
            tmp_txt=os.path.join(
                locator.working_directory, args['template_txt']),
            tmp_keyval_str=args['template_keyvals'],
            run_dir=args['run_dir'],
            id2path=from_qtc.obtools.get_smiles_filename,
            job_argv=job_argv,
            logger=logger
        )


def divide(argv):
    """ divide into binary categories, by key
    """
    keys = ('rad-rad', 'high-spin')
    parser = _action_parser(prog='automech divide',
                            log_file_name='divide.log',
                            prefix=True)
    parser.add_argument('key',
                        type=str,
                        help="options: {:s}".format(', '.join(keys)))
    parser.add_argument('dir1',
                        type=str,
                        help="directory name for reactions in category")
    parser.add_argument('dir2',
                        type=str,
                        help="directory name for reactions out of category")
    parser.add_argument('-r', '--reactions_csv',
                        type=str,
                        default='reactions.csv',
                        help="[i(o)] csv file with 'reaction_id' column")
    parser.add_argument('-R',
                        '--reactions_csv_out',
                        type=str,
                        default='reactions.csv',
                        help="[o] csv file with 'reaction_id' column")
    _get_help(parser, argv)
    args = vars(parser.parse_args(argv))

    with _ChangeDirectory(args['prefix']) as locator:
        logger = _logger(
            log_file_name=args['log_file_name'],
            log_level=args['log_level'],
            print_out=args['print_out']
        )

        automechanic.io.divide(
            key=args['key'],
            dir1=args['dir1'],
            dir2=args['dir2'],
            rxn_csv=os.path.join(
                locator.working_directory, args['reactions_csv']),
            rxn_csv_out=args['reactions_csv_out'],
            logger=logger
        )


# helpers
def _route_subcommand(argv, cmd, subcmd_dct):
    """ subcommand function
    """
    hlp_str = 'commands: ' + ', '.join(subcmd_dct.keys())

    parser = _empty_parser(cmd)
    parser.add_argument('<command>',
                        type=str,
                        help=hlp_str)
    _get_help(parser, argv)

    args = vars(parser.parse_args(argv[:1]))

    subcmd = args['<command>']

    if subcmd not in subcmd_dct:
        raise ValueError("Unrecognized command '{:s}'\n{:s}"
                         .format(subcmd, hlp_str))

    subcmd_dct[subcmd](argv[1:])


def _split_command_args(argv):
    automech_argv = argv
    job_argv = None
    if 'cmd' in argv:
        cmd_pos = argv.index('cmd') + 1
        automech_argv = argv[:cmd_pos]
        job_argv = argv[cmd_pos:]
    else:
        automech_argv.append('cmd')
    return automech_argv, job_argv


def _init_parser(*ainf_lst):
    spc_out_help_str = "columns: 'species_id', 'path'"
    rxn_out_help_str = "columns: 'reaction_id'"
    ainf_lst += (
        _arginfo_add_help(SPC_CSV_OPT_OUT_AINF, spc_out_help_str),
        _arginfo_add_help(RXN_CSV_OPT_OUT_AINF, rxn_out_help_str),
        GEOM_DIR_AINF,
        PREFIX_AINF,
        _arginfo_set_default(LOG_FILE_NAME_AINF, 'init.log'),
        LOG_LEVEL_AINF,
        PRINT_OUT_AINF
    )
    parser = _parser(prog='automech init', ainf_lst=ainf_lst)
    return parser


def _reactions_run_batch_parser(cls):
    parser = _action_parser(prog='automech {:s} run_batch'.format(cls),
                            log_file_name='run.log',
                            prefix=True)

    parser.add_argument('-t',
                        '--template_txt',
                        type=str,
                        default='template.txt',
                        help="TorsScan input with .format placeholders")
    parser.add_argument('-y',
                        '--template_keyvals',
                        type=str,
                        default="nodes:d",
                        help="template substitutions: 'key:val|key:val|...'")
    parser.add_argument('-s', '--species_csv',
                        type=str,
                        default='species.csv',
                        help="[i] csv with 'species_id' and 'path' columns")
    parser.add_argument('-b', '--batch_csv',
                        type=str,
                        default='reactions.csv',
                        help="[i] csv with 'reaction_id' column")
    parser.add_argument('-r', '--reactions_csv',
                        type=str,
                        default='reactions.csv',
                        help="[i(o)] reactions csv generated by the "
                             "initializer for this reaction class")
    parser.add_argument('-D', '--run_dir',
                        type=str,
                        default='runs',
                        help="[o] directory for running reaction jobs")

    parser.add_argument('cmd <commands for individual job>')
    return parser


def _reactions_init_parser(cls):
    parser = _action_parser(prog='automech {:s} init'.format(cls),
                            log_file_name='init.log',
                            prefix=True)

    parser.add_argument(dest='<reactions_csv>',
                        type=str,
                        default='reactions.csv',
                        help="[i(o)] csv with 'reaction_id' column")
    parser.add_argument(dest='<species_csv>',
                        type=str,
                        default='species.csv',
                        help="[i] csv with 'species_id' and 'path' columns")
    parser.add_argument('-R',
                        '--reactions_csv_out',
                        type=str,
                        default='reactions.csv',
                        help="[o] csv file with 'reaction_id' and 'class' "
                             "columns")
    parser.add_argument('-C',
                        '--candidates_csv_out',
                        type=str,
                        default='candidates.csv',
                        help="[o] csv file with 'reaction_id' column")
    return parser


def _reactions_run_parser(cls):
    parser = _action_parser(prog='automech {:s} run'.format(cls),
                            log_file_name='run.log',
                            prefix=True)

    parser.add_argument(dest='<template_txt>',
                        type=str,
                        default='template.txt',
                        help='[i] txt with str.format() replacement fields')
    parser.add_argument(dest='<reactions_csv>',
                        type=str,
                        default='reactions.csv',
                        help="[i(o)] csv with 'reaction_id' and 'index' "
                             "columns")
    parser.add_argument(dest='<species_csv>',
                        type=str,
                        default='species.csv',
                        help="[i] csv with 'species_id' and 'path' columns")
    parser.add_argument('-n', '--nodes',
                        type=str,
                        nargs='+',
                        default='d',
                        help="one or more nodes to run on")
    parser.add_argument('-i', '--indices',
                        type=str,
                        nargs='+',
                        default='0-',
                        help="indices and index ranges for the 'index' "
                             "column in <reactions_csv>")
    parser.add_argument('-D', '--run_dir',
                        type=str,
                        default='runs',
                        help="[o] directory for running reaction jobs")

    parser.add_argument('cmd <commands for individual job>')
    return parser


def _empty_parser(prog):
    parser = ArgumentParser(prog=prog, formatter_class=Formatter,
                            add_help=False)
    return parser


def _action_parser(prog, log_file_name, prefix=False):
    parser = _empty_parser(prog)
    log_file_name_arginfo = _arginfo_set_default(
        LOG_FILE_NAME_AINF, log_file_name)
    parser.add_argument(*PRINT_OUT_AINF[0],
                        **dict(PRINT_OUT_AINF[1]))
    parser.add_argument(*LOG_LEVEL_AINF[0],
                        **dict(LOG_LEVEL_AINF[1]))
    parser.add_argument(*log_file_name_arginfo[0],
                        **dict(log_file_name_arginfo[1]))

    if prefix:
        parser.add_argument(*PREFIX_AINF[0],
                            **dict(PREFIX_AINF[1]))

    return parser


def _logger(log_file_name, log_level=logging.INFO, print_out=False):
    automechanic.io.timestamp_if_exists(log_file_name)

    logger = logging.getLogger()
    logger.setLevel(log_level)

    fhandler = logging.FileHandler(log_file_name, mode='w')
    fhandler.setLevel(log_level)

    formatter = logging.Formatter('%(message)s')
    fhandler.setFormatter(formatter)

    logger.addHandler(fhandler)

    if print_out:
        shandler = logging.StreamHandler(sys.stdout)
        shandler.setLevel(log_level)
        shandler.setFormatter(formatter)
        logger.addHandler(shandler)

    return logger


class _ChangeDirectory(object):

    def __init__(self, path):
        self.working_directory = os.getcwd()
        self.other_directory = os.path.abspath(path)

    def __enter__(self):
        if not os.path.exists(self.other_directory):
            os.mkdir(self.other_directory)
        os.chdir(self.other_directory)
        return self

    def __exit__(self, _type, _value, _traceback):
        os.chdir(self.working_directory)


if __name__ == '__main__':
    main(sys.argv[1:])
